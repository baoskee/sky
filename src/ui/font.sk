namespace UI {
  enum Font {
    CODE_FONT
    MARGIN_FONT
    UI_FONT
  }

  def roundUpToNextTabStop(value double, spacing double) double {
    return Math.floor(value / spacing + 1) * spacing
  }

  interface FontInstance {
    def font Font
    def size double
    def lineHeight double
    def advanceWidth(codePoint int) double # This assumes a 1:1 mapping between glyphs and code points
    def renderGlyph(codePoint int) Graphics.Glyph # This may return null
  }

  # The current state is only valid after a call to "reset" and "moveNext"
  class AdvanceWidthIterator {
    const _unicodeIterator = Unicode.StringIterator.new
    var _font FontInstance = null
    var _currentIndex = 0
    var _advanceWidthFromLeft = 0.0
    var _spaceAdvanceWidth = 0.0
    var _tabStopSpacing = 0.0

    def currentIndex int {
      return _currentIndex
    }

    def advanceWidthFromLeft double {
      return _advanceWidthFromLeft
    }

    def reset(text string) {
      _unicodeIterator.reset(text, 0)
      _currentIndex = 0
      _advanceWidthFromLeft = 0
    }

    def setFont(font FontInstance, indent int) {
      if _font != font {
        _font = font
        _spaceAdvanceWidth = font.advanceWidth(' ')
      }
      _tabStopSpacing = _spaceAdvanceWidth * indent
    }

    def nextCodePoint int {
      var c = _unicodeIterator.nextCodePoint
      _currentIndex = _unicodeIterator.index
      if c != -1 {
        if c == '\t' {
          _advanceWidthFromLeft = roundUpToNextTabStop(_advanceWidthFromLeft, _tabStopSpacing)
        } else {
          _advanceWidthFromLeft += _font.advanceWidth(c)
        }
      }
      return c
    }

    # This assumes the index is between code points, not in the middle of one
    def seekTo(index int) {
      var iterator = _unicodeIterator
      var oldIndex = iterator.index
      var oldAdvanceWidth = _advanceWidthFromLeft

      # Start from the beginning
      if index < oldIndex / 2 {
        iterator.index = 0
        _currentIndex = 0
        _advanceWidthFromLeft = 0
        while iterator.index < index && nextCodePoint != -1 {}
      }

      # Back up
      else if index < oldIndex {
        iterator.index = index
        _currentIndex = index
        _advanceWidthFromLeft = 0
        while iterator.index < oldIndex && nextCodePoint != -1 {}
        iterator.index = index
        _currentIndex = index
        _advanceWidthFromLeft = oldAdvanceWidth - _advanceWidthFromLeft
      }

      # Keep going
      else {
        while index > iterator.index && nextCodePoint != -1 {}
      }
    }
  }

  namespace AdvanceWidthIterator {
    const INSTANCE = new
  }
}
