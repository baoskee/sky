namespace Browser {
  enum DeltaMode {
    PIXEL
    LINE
    PAGE
  }

  const _whichToKeyCode IntMap<Editor.KeyCode> = {
    8:   .BACKSPACE,
    13:  .ENTER,
    27:  .ESCAPE,
    33:  .PAGE_UP,
    34:  .PAGE_DOWN,
    35:  .END,
    36:  .HOME,
    37:  .ARROW_LEFT,
    38:  .ARROW_UP,
    39:  .ARROW_RIGHT,
    40:  .ARROW_DOWN,
    44:  .COMMA,
    46:  .DELETE,
    59:  .SEMICOLON,
    186: .SEMICOLON,
    188: .COMMA,
    190: .PERIOD,
  }

  class CanvasElement :: Editor.PixelRenderer {
    var _width = 0
    var _height = 0
    var _pixelScale = 0.0
    var _fontSize = 0.0
    var _lineHeight = 0.0
    var _isInvalid = false
    var _fontText = ""
    var _marginFontText = ""
    var _advanceWidth = 0.0
    var _marginAdvanceWidth = 0.0
    var _previousFont Editor.Font = .DEFAULT
    var _isPreviousFontValid = false
    var _idleCount = 0
    var _element = document.createElement("canvas")
    var _mousemove fn(dynamic) = null
    var _mouseup fn(dynamic) = null
    var _view Editor.View = null
    var _platform Editor.Platform = null
    var _shortcuts Editor.ShortcutMap = null
    var _textarea = document.createElement("textarea")
    var _previousValue = ""
    var _fontContext = document.createElement("canvas").getContext("2d")

    def new(platform Editor.Platform, shortcuts Editor.ShortcutMap) {
      _platform = platform
      _shortcuts = shortcuts
      _installEventHandlers
    }

    def _renderNothing
    def setDefaultBackgroundColor(color Graphics.RGBA)
    def fillBox(x double, y double, width double, height double, color Graphics.RGBA)
    def fillRoundedBox(x double, y double, width double, height double, color Graphics.RGBA, radius double)
    def strokePolyline(coordinates List<double>, color Graphics.RGBA, thickness double)
    def renderBoxShadow(boxX double, boxY double, boxWidth double, boxHeight double, clipX double, clipY double, clipWidth double, clipHeight double, blurRadius double)
    def renderText(x double, y double, text string, font Editor.Font, color Graphics.RGBA)

    def setView(view Editor.View) {
      if _view != view {
        _view = view

        if view != null {
          view.resize(_width, _height)
          view.resizeFont(_advanceWidth, _marginAdvanceWidth, _lineHeight)
          invalidate
        }
      }
    }

    def width int {
      return _width
    }

    def height int {
      return _height
    }

    def pixelScale double {
      return _pixelScale
    }

    def fontSize double {
      return _fontSize
    }

    def lineHeight double {
      return _lineHeight
    }

    def invalidate {
      _isInvalid = true
    }

    def setCursor(cursor Editor.Cursor) {
      _element.style.cursor =
        cursor == .TEXT ? "text" :
        "default"
    }

    def tick {
      _render
    }

    def changeFont(fontSize double, marginFontSize double, lineHeight double, fontNames List<string>) {
      fontNames = fontNames.clone
      fontNames.append("monospace")

      var fontSuffix = "px " + ",".join(fontNames)
      _fontSize = fontSize
      _fontText = "\(fontSize)\(fontSuffix)"
      _marginFontText = "\(marginFontSize)\(fontSuffix)"
      _fontContext.font = _fontText
      _advanceWidth = _fontContext.measureText("x".repeat(100)).width / 100
      _marginAdvanceWidth = _advanceWidth * marginFontSize / fontSize
      _lineHeight = lineHeight

      if _view != null {
        _view.resizeFont(_advanceWidth, _marginAdvanceWidth, _lineHeight)
      }
    }

    def _changeValue(value string) {
      _textarea.value = value
      _previousValue = value
    }

    def _render {
      # Skip rendering if not invalid
      if !_isInvalid {
        _idleCount++

        # Render something at 10 fps even when idle otherwise Chrome's
        # render loop goes idle and stutters when starting back up
        if _idleCount == 6 {
          _renderNothing
          _idleCount = 0
        }

        return
      }

      # Reset render state
      _idleCount = 0
      _isInvalid = false
      _isPreviousFontValid = false

      # Delegate to the view
      _view?.render
    }

    def _updateSize {
      var width int = _element.clientWidth
      var height int = _element.clientHeight
      var pixelScale double = window.devicePixelRatio ? window.devicePixelRatio : 1

      # Safari broke devicePixelRatio
      if _platform.userAgent == .SAFARI {
        pixelScale *= Math.sqrt(document.width * document.height / (window.innerWidth * window.innerHeight))
      }

      if _width != width || _height != height || _pixelScale != pixelScale {
        _element.width = Math.round(width * pixelScale)
        _element.height = Math.round(height * pixelScale)
        _width = width
        _height = height
        _pixelScale = pixelScale
        _view?.resize(width, height)
      }
    }

    def stretchToFitElement(element dynamic) {
      var style = _element.style
      style.position = "fixed"
      style.left = 0
      style.top = 0
      style.width = "100%"
      style.height = "100%"

      on(window, "resize", e => {
        _updateSize
        _render
      })

      element.style.overflow = "hidden"
      element.appendChild(_element)
      element.appendChild(_textarea)
      _updateSize
    }

    def focusKeyboardInput {
      _textarea.enabled = true
      _textarea.focus()
    }

    def blurKeyboardInput {
      _textarea.blur()
      _textarea.enabled = false
    }

    # https://bugs.chromium.org/p/chromium/issues/detail?id=588434
    def avoidChromeBugOnWindowFocus {
      if _platform.userAgent == .CHROME {
        _width = 1
        _height = 1
        _element.width = 1
        _element.height = 1
        _updateSize
        _render
      }
    }

    def _modifiersFromEvent(event dynamic) Editor.Modifiers {
      return
        (event.altKey ? .ALT : 0) |
        (event.metaKey ? .META : 0) |
        (event.shiftKey ? .SHIFT : 0) |
        (event.ctrlKey ? .CONTROL : 0)
    }

    def _mouseEventFromEvent(e dynamic) Editor.MouseEvent {
      var bounds = _element.getBoundingClientRect()
      var x double = e.pageX - bounds.left
      var y double = e.pageY - bounds.top
      return Editor.MouseEvent.new(x, y, _modifiersFromEvent(e))
    }

    enum ChangeDragHandlers {
      LOCAL
      GLOBAL
    }

    def _changeDragHandlers(mode ChangeDragHandlers) {
      var old = mode == .GLOBAL ? _element : document
      var new = mode == .GLOBAL ? document : _element

      off(old, "mousemove", _mousemove)
      off(old, "mouseup", _mouseup)

      on(new, "mousemove", _mousemove)
      on(new, "mouseup", _mouseup)
    }

    def _handleInput {
      # Text input in browsers really sucks. There's no API for text insertion
      # events so the only way to do it is to shove an input field off screen
      # somewhere, give it focus, and keep checking for inserted text. We keep
      # clearing the input field so that adjacent inputs don't interfere with
      # each other. Listening for key presses and decoding key codes is not a
      # good way to do things because that doesn't account for international
      # keyboard layouts and IMEs. This method still doesn't get dead characters
      # but at least it's close. A textarea is used instead of an input field
      # because we need newlines too.
      if _textarea.value != _previousValue {
        _view?.insertText(_textarea.value)
        _changeValue("")
      }
    }

    def _installEventHandlers {
      _mousemove = e => {
        _view?.handleMouseMove(_mouseEventFromEvent(e))
      }

      _mouseup = e => {
        _view?.handleMouseUp(_mouseEventFromEvent(e))
        _changeDragHandlers(.LOCAL)
      }

      on(_element, "mousedown", e => {
        e.preventDefault()
        focusKeyboardInput
        _view?.handleMouseDown(_mouseEventFromEvent(e))
        _changeDragHandlers(.GLOBAL)
      })

      on(_element, "contextmenu", e => {
        e.preventDefault()
      })

      on(_element, "wheel", e => {
        # Pinch-to-zoom in Chrome generates scroll events with the control key
        if e.ctrlKey {
          return
        }

        # Scroll deltas in Firefox are too small unless we handle deltaMode
        var deltaX = e.deltaX
        var deltaY = e.deltaY
        var deltaMode = e.deltaMode
        var scale =
          deltaMode == DeltaMode.LINE ? _lineHeight :
          deltaMode == DeltaMode.PAGE ? _height :
          1

        _view?.handleScroll(deltaX * scale, deltaY * scale)
        e.preventDefault()
      })

      on(_textarea, "blur", e => blurKeyboardInput)
      on(_textarea, "input", e => _handleInput)
      on(_textarea, "keydown", e => _handleKeyDown(e))

      var style = _textarea.style
      style.position = "absolute"
      style.right = "200%"
      style.bottom = "200%"

      _changeDragHandlers(.LOCAL)
    }

    def _keyCodeFromEvent(event dynamic) Editor.KeyCode {
      var which = event.which as int

      if which >= 'A' && which <= 'Z' {
        return (Editor.KeyCode.LETTER_A - 'A' + which) as Editor.KeyCode
      }

      if which >= '0' && which <= '9' {
        return (Editor.KeyCode.NUMBER_0 - '0' + which) as Editor.KeyCode
      }

      return _whichToKeyCode.get(event.which as int, .NONE)
    }

    def _handleKeyDown(event dynamic) {
      if _view == null {
        return
      }

      var modifiers = _modifiersFromEvent(event)
      var action = _shortcuts.get( _keyCodeFromEvent(event), modifiers)
      var view = _view

      # Clipboard handling in the browser really, really sucks. The standard is
      # horrible and browsers do different things. We can't use the cut, copy,
      # and paste events because Firefox doesn't even fire cut/copy if the
      # element with focus has no selected text. Instead, try to guess when a
      # cut or copy event is about to happen and quickly set the selected text.
      # Clear the selected text immediately afterwards so that it doesn't
      # interfere with our text input detection. This hack won't work with the
      # browser's cut/copy/paste commands triggered through the menu or through
      # other assistive devices.
      if action == .CUT || action == .COPY {
        var selection = view.selection.isEmpty ? view.selectionExpandedToLines : view.selection
        _changeValue(view.textInSelection(selection))
        _textarea.select()
        dynamic.setTimeout(=> _changeValue(""), 50)

        if action == .CUT {
          view.changeSelection(selection, .DO_NOT_SCROLL)
          view.insertText("")
        }
      }

      # Don't call preventDefault() for paste events since we want the paste to
      # happen. That way the change will go through our regular text insertion
      # detection.
      else if action != .NONE && action != .PASTE {
        event.preventDefault()
        view.triggerAction(action)
      }
    }
  }
}
