namespace Browser {
  class CanvasElementWebGL : CanvasElement {
    var _context Context = null
    var _pool Graphics.BufferPool = null
    var _solidBatch Graphics.SolidBatch = null
    var _glyphBatch Graphics.GlyphBatch = null
    var _font Graphics.Font = null
    var _marginFont Graphics.Font = null
    var _dropShadowMaterial Graphics.Material = null
    var _dropShadowVertices = FixedArray.new(4 * 2 * 4)

    def new(platform Editor.Platform, shortcuts Editor.ShortcutMap) {
      super(platform, shortcuts)

      var gl WebGLRenderingContext = null
      var options dynamic = {
        "alpha": false,
        "antialias": false,
        "depth": false,
        "preserveDrawingBuffer": true,
        "stencil": false,
      }

      # Attempt to use the official WebGL string
      try {
        gl = _element.getContext("webgl", options)
      }

      # Fall back to the older unofficial WebGL string
      gl ?= _element.getContext("experimental-webgl", options)

      _context = Context.new(gl)
      _pool = Graphics.BufferPool.new(_context)
      _solidBatch = Graphics.SolidBatch.new(_context, _pool)
      _glyphBatch = Graphics.GlyphBatch.new(platform, _context, _pool)
      _dropShadowMaterial = _context.createMaterial(.POSITION_F2, GLSLX_SOURCE_DROP_SHADOW_VERTEX, GLSLX_SOURCE_DROP_SHADOW_FRAGMENT)

      Log.info("initialized WebGL canvas")
    }

    over setDefaultBackgroundColor(color Graphics.RGBA) {
      _glyphBatch.setBackgroundColor(color)
    }

    over _renderNothing {
      _glyphBatch.flush
      _solidBatch.fillRect(0, 0, 1, 1, .TRANSPARENT)
    }

    over _updateSize {
      super
      _context.resize(_element.width, _element.height)
      _solidBatch.resize(_width, _height, _pixelScale)
      _glyphBatch.resize(_width, _height, _pixelScale)
      _dropShadowMaterial.setUniformVec2(GLSLX_NAME_SCALE2, 2.0 / _width, -2.0 / _height)
    }

    over changeFont(fontSize double, marginFontSize double, lineHeight double, fontNames List<string>) {
      super(fontSize, marginFontSize, lineHeight, fontNames)
      _font = _glyphBatch.createFont(fontNames, fontSize)
      _marginFont = _glyphBatch.createFont(fontNames, marginFontSize)
    }

    over _render {
      super
      _solidBatch.flush
      _glyphBatch.flush
    }

    over fillBox(x double, y double, width double, height double, color Graphics.RGBA) {
      if x >= _width || y >= _height || x + width <= 0 || y + height <= 0 {
        return
      }

      _glyphBatch.flush
      _solidBatch.fillRect(x, y, width, height, color.premultiplied)
    }

    over fillRoundedBox(x double, y double, width double, height double, color Graphics.RGBA, radius double) {
      if x >= _width || y >= _height || x + width <= 0 || y + height <= 0 {
        return
      }

      radius = Math.min(radius, width / 2, height / 2)

      var coordinates List<double> = []
      var minX = x + radius
      var minY = y + radius
      var maxX = x + width - radius
      var maxY = y + height - radius
      var isClampedX = radius == width / 2
      var isClampedY = radius == height / 2

      _appendQuarterTurn(coordinates, minX, minY, radius, -Math.PI, -Math.PI / 2, isClampedY)
      _appendQuarterTurn(coordinates, maxX, minY, radius, -Math.PI / 2, 0, isClampedX)
      _appendQuarterTurn(coordinates, maxX, maxY, radius, 0, Math.PI / 2, isClampedY)
      _appendQuarterTurn(coordinates, minX, maxY, radius, Math.PI / 2, Math.PI, isClampedX)
      _glyphBatch.flush
      _solidBatch.fillConvexPolygon(coordinates, color.premultiplied)
    }

    over strokePolyline(coordinates List<double>, color Graphics.RGBA, thickness double) {
      assert(coordinates.count % 2 == 0)
      _glyphBatch.flush
      _solidBatch.strokeNonOverlappingPolyline(coordinates, color.premultiplied, thickness, .OPEN)
    }

    over renderBoxShadow(
      boxX double, boxY double, boxWidth double, boxHeight double,
      clipX double, clipY double, clipWidth double, clipHeight double,
      shadowAlpha double, blurSigma double) {

      if clipX >= _width || clipY >= _height || clipX + clipWidth <= 0 || clipY + clipHeight <= 0 {
        return
      }

      _solidBatch.flush
      _glyphBatch.flush

      _dropShadowVertices.setFloat(0, clipX)
      _dropShadowVertices.setFloat(4, clipY)

      _dropShadowVertices.setFloat(8, clipX + clipWidth)
      _dropShadowVertices.setFloat(12, clipY)

      _dropShadowVertices.setFloat(16, clipX)
      _dropShadowVertices.setFloat(20, clipY + clipHeight)

      _dropShadowVertices.setFloat(24, clipX + clipWidth)
      _dropShadowVertices.setFloat(28, clipY + clipHeight)

      var area = _pool.allocate(.POSITION_F2, _dropShadowVertices)

      if area != null {
        _dropShadowMaterial.setUniformVec4(GLSLX_NAME_DROP_SHADOW_BOX, boxX, boxY, boxX + boxWidth, boxY + boxHeight)
        _dropShadowMaterial.setUniformVec2(GLSLX_NAME_DROP_SHADOW_OPTIONS, shadowAlpha, blurSigma)
        _context.draw(.TRIANGLE_STRIP, _dropShadowMaterial, area)
        area.free
      }
    }

    over renderText(x double, y double, text string, font Editor.Font, color Graphics.RGBA) {
      if x >= _width || y >= _height || y + _fontSize <= 0 {
        return
      }

      var iterator = Unicode.StringIterator.INSTANCE.reset(text, 0)
      var graphicsFont = font == .MARGIN ? _marginFont : _font

      _solidBatch.flush
      y += _fontSize - graphicsFont.size
      color = color.premultiplied

      for codePoint = iterator.nextCodePoint; codePoint != -1; codePoint = iterator.nextCodePoint {
        x += _glyphBatch.appendGlyph(graphicsFont, codePoint, x, y, color)
      }
    }

    def _appendQuarterTurn(coordinates List<double>, centerX double, centerY double, radius double, fromAngle double, toAngle double, skipStartPoint bool) {
      var n = 1 + Math.ceil(radius * _pixelScale / Math.PI) as int
      for i = skipStartPoint as int; i <= n; i++ {
        var angle = fromAngle + (toAngle - fromAngle) * i / n
        coordinates.append(centerX + Math.cos(angle) * radius)
        coordinates.append(centerY + Math.sin(angle) * radius)
      }
    }
  }
}
