namespace Browser {
  class CanvasElementWebGL : CanvasElement {
    var _context Context = null
    var _solidBatch Graphics.SolidBatch = null
    var _glyphBatch Graphics.GlyphBatch = null
    var _font Graphics.Font = null
    var _marginFont Graphics.Font = null
    var _dropShadowMaterial Graphics.Material = null
    var _dropShadowVertices = FixedArray.new(4 * 2 * 4)

    def new(platform Editor.Platform, shortcuts Editor.ShortcutMap) {
      super(platform, shortcuts)

      var gl WebGLRenderingContext = null
      var options dynamic = {
        "alpha": false,
        "antialias": false,
        "depth": false,
        "preserveDrawingBuffer": true,
        "stencil": false,
      }

      # Attempt to use the official WebGL string
      try {
        gl = _element.getContext("webgl", options)
      }

      # Fall back to the older unofficial WebGL string
      gl ?= _element.getContext("experimental-webgl", options)

      _context = Context.new(gl)
      _solidBatch = Graphics.SolidBatch.new(_context)
      _glyphBatch = Graphics.GlyphBatch.new(platform, _context)
      _dropShadowMaterial = _context.createMaterial(.POSITION_F2, GLSLX_SOURCE_DROP_SHADOW_VERTEX, GLSLX_SOURCE_DROP_SHADOW_FRAGMENT)

      Log.info("initialized WebGL canvas")
    }

    over setDefaultBackgroundColor(color Graphics.RGBA) {
      _glyphBatch.setBackgroundColor(color)
    }

    over _renderNothing {
      _glyphBatch.flush
      _solidBatch.fillRect(0, 0, 1, 1, .TRANSPARENT)
    }

    over _updateSize {
      super
      _context.resize(_element.width, _element.height)
      _solidBatch.resize(_width, _height, _pixelScale)
      _glyphBatch.resize(_width, _height, _pixelScale)
      _dropShadowMaterial.setUniformVec2(GLSLX_NAME_SCALE2, 2.0 / _width, -2.0 / _height)
    }

    over changeFont(fontSize double, marginFontSize double, lineHeight double, fontNames List<string>) {
      super(fontSize, marginFontSize, lineHeight, fontNames)
      _font = _glyphBatch.createFont(fontNames, fontSize)
      _marginFont = _glyphBatch.createFont(fontNames, marginFontSize)
    }

    over _render {
      super
      _solidBatch.flush
      _glyphBatch.flush
    }

    over fillRect(x double, y double, width double, height double, color Graphics.RGBA) {
      _glyphBatch.flush
      _solidBatch.fillRect(x, y, width, height, color.premultiplied)
    }

    over fillRoundedRect(x double, y double, width double, height double, color Graphics.RGBA, radius double) {
      _glyphBatch.flush
      _solidBatch.fillRoundedRect(x, y, width, height, color.premultiplied, radius)
    }

    over strokePolyline(coordinates List<double>, color Graphics.RGBA, thickness double) {
      assert(coordinates.count % 2 == 0)
      _glyphBatch.flush
      _solidBatch.strokeNonOverlappingPolyline(coordinates, color.premultiplied, thickness, .OPEN)
    }

    over renderRectShadow(
      boxX double, boxY double, boxWidth double, boxHeight double,
      clipX double, clipY double, clipWidth double, clipHeight double,
      shadowAlpha double, blurSigma double) {

      if clipX >= _width || clipY >= _height || clipX + clipWidth <= 0 || clipY + clipHeight <= 0 {
        return
      }

      _solidBatch.flush
      _glyphBatch.flush

      _dropShadowVertices.setFloat(0, clipX)
      _dropShadowVertices.setFloat(4, clipY)

      _dropShadowVertices.setFloat(8, clipX + clipWidth)
      _dropShadowVertices.setFloat(12, clipY)

      _dropShadowVertices.setFloat(16, clipX)
      _dropShadowVertices.setFloat(20, clipY + clipHeight)

      _dropShadowVertices.setFloat(24, clipX + clipWidth)
      _dropShadowVertices.setFloat(28, clipY + clipHeight)

      _dropShadowMaterial.setUniformVec4(GLSLX_NAME_DROP_SHADOW_BOX, boxX, boxY, boxX + boxWidth, boxY + boxHeight)
      _dropShadowMaterial.setUniformVec2(GLSLX_NAME_DROP_SHADOW_OPTIONS, shadowAlpha, blurSigma)
      _context.draw(.TRIANGLE_STRIP, _dropShadowMaterial, _dropShadowVertices)
    }

    over renderText(x double, y double, text string, font Editor.Font, color Graphics.RGBA) {
      if x >= _width || y >= _height || y + _fontSize <= 0 {
        return
      }

      var iterator = Unicode.StringIterator.INSTANCE.reset(text, 0)
      var graphicsFont = font == .MARGIN ? _marginFont : _font

      _solidBatch.flush
      y += _fontSize - graphicsFont.size
      color = color.premultiplied

      for codePoint = iterator.nextCodePoint; codePoint != -1; codePoint = iterator.nextCodePoint {
        x += _glyphBatch.appendGlyph(graphicsFont, codePoint, x, y, color)
      }
    }
  }
}
