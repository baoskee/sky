namespace Browser {
  class CanvasElementWebGL : CanvasElement {
    var _context Context = null
    var _solidBatch Graphics.SolidBatch = null
    var _glyphBatch Graphics.GlyphBatch = null
    var _dropShadow Graphics.DropShadow = null
    var _font Graphics.Font = null
    var _marginFont Graphics.Font = null

    def new(platform Editor.Platform, shortcuts Editor.ShortcutMap) {
      super(platform, shortcuts)

      var gl WebGLRenderingContext = null
      var options dynamic = {
        "alpha": false,
        "antialias": false,
        "depth": false,
        "preserveDrawingBuffer": true,
        "stencil": false,
      }

      # Attempt to use the official WebGL string
      try {
        gl = _element.getContext("webgl", options)
      }

      # Fall back to the older unofficial WebGL string
      gl ?= _element.getContext("experimental-webgl", options)

      _context = Context.new(gl)
      _solidBatch = Graphics.SolidBatch.new(_context)
      _glyphBatch = Graphics.GlyphBatch.new(platform, _context)
      _dropShadow = Graphics.DropShadow.new(_context)

      Log.info("initialized WebGL canvas")
    }

    over setDefaultBackgroundColor(color Graphics.RGBA) {
      _glyphBatch.setBackgroundColor(color)
    }

    over _renderNothing {
      _glyphBatch.flush
      _solidBatch.fillRect(0, 0, 1, 1, .TRANSPARENT)
    }

    over _updateSize {
      super
      _context.resize(_element.width, _element.height)
      _solidBatch.resize(_width, _height, _pixelScale)
      _glyphBatch.resize(_width, _height, _pixelScale)
      _dropShadow.resize(_width, _height)
      _font.resize(_pixelScale)
      _marginFont.resize(_pixelScale)
    }

    over changeFont(fontSize double, marginFontSize double, lineHeight double, fontNames List<string>) {
      super(fontSize, marginFontSize, lineHeight, fontNames)
      _font = Graphics.Font.create(_platform, fontNames, fontSize)
      _marginFont = Graphics.Font.create(_platform, fontNames, marginFontSize)
    }

    over _render {
      super
      _solidBatch.flush
      _glyphBatch.flush
    }

    over fillRect(x double, y double, width double, height double, color Graphics.RGBA) {
      _glyphBatch.flush
      _solidBatch.fillRect(x, y, width, height, color.premultiplied)
    }

    over fillRoundedRect(x double, y double, width double, height double, color Graphics.RGBA, radius double) {
      _glyphBatch.flush
      _solidBatch.fillRoundedRect(x, y, width, height, color.premultiplied, radius)
    }

    over strokePolyline(coordinates List<double>, color Graphics.RGBA, thickness double) {
      assert(coordinates.count % 2 == 0)
      _glyphBatch.flush
      _solidBatch.strokeNonOverlappingPolyline(coordinates, color.premultiplied, thickness, .OPEN)
    }

    over renderRectShadow(
      rectX double, rectY double, rectWidth double, rectHeight double,
      clipX double, clipY double, clipWidth double, clipHeight double,
      shadowAlpha double, blurSigma double) {

      _solidBatch.flush
      _glyphBatch.flush
      _dropShadow.render(rectX, rectY, rectWidth, rectHeight, clipX, clipY, clipWidth, clipHeight, shadowAlpha, blurSigma)
    }

    over renderText(x double, y double, text string, font Editor.Font, color Graphics.RGBA) {
      if x >= _width || y >= _height || y + _fontSize <= 0 {
        return
      }

      var iterator = Unicode.StringIterator.INSTANCE.reset(text, 0)
      var graphicsFont = font == .MARGIN ? _marginFont : _font

      _solidBatch.flush
      y += _fontSize - graphicsFont.size
      color = color.premultiplied

      for codePoint = iterator.nextCodePoint; codePoint != -1; codePoint = iterator.nextCodePoint {
        x += _glyphBatch.appendGlyph(graphicsFont, codePoint, x, y, color)
      }
    }
  }
}
