namespace Browser {
  class GlyphProvider :: Graphics.GlyphProvider {
    const _fontNames List<string>
    var _maskData Int32Array = null
    var _canvasSize = 0
    var _fontSize = 0.0
    var _context = document.createElement("canvas").getContext("2d")

    def resize(fontSize double) {
      if _fontSize == fontSize {
        return
      }

      # Assume glyphs won't ever grow extend out more than twice the font size.
      # Because the canvas text API is so terrible, we have no way of knowing
      # what the actual glyph size is, so this is the best we can do.
      _canvasSize = Math.ceil(fontSize * 2) as int
      _context.canvas.width = _canvasSize
      _context.canvas.height = _canvasSize

      # This must be set after resizing the canvas or it will be reset
      _context.font = "\(fontSize)px " + ", ".join(_fontNames)
      _maskData = Int32Array.new(_canvasSize * _canvasSize)
      _fontSize = fontSize
    }

    def advanceWidth(codePoint int) double {
      return _context.measureText(string.fromCodePoint(codePoint).repeat(100)).width / 100
    }

    def render(codePoint int, advanceWidth double) Graphics.Glyph {
      # Round the origin coordinates because some browsers do hinting
      var size = _canvasSize
      var originX = size / 4
      var originY = size / 4
      var maskData = _maskData

      # Render the glyph three times at different offsets
      for i in 0..3 {
        _context.clearRect(0, 0, size, size)
        _context.fillText(string.fromCodePoint(codePoint), originX + i / 3.0, originY + _fontSize)

        var data Uint8ClampedArray = _context.getImageData(0, 0, size, size).data
        var shift = i * 8

        assert(data.length == maskData.length * 4)

        for j = 0, k = 3; j < maskData.length; j++, k += 4 {
          maskData[j] = shift != 0 ? maskData[j] | data[k] << shift : data[k]
        }
      }

      # Trim the image in preparation for using it in an atlas texture
      var minX = 0
      var minY = 0
      var maxX = size
      var maxY = size

      # Trim the left
      for found = false; minX < maxX; minX++ {
        for y = minY, i = minX + y * size; !found && y < maxY; y++, i += size {
          found = maskData[i] > 0
        }
        if found {
          break
        }
      }

      # Trim the right
      for found = false; minX < maxX; maxX-- {
        for y = minY, i = maxX - 1 + y * size; !found && y < maxY; y++, i += size {
          found = maskData[i] > 0
        }
        if found {
          break
        }
      }

      # Trim the top
      for found = false; minY < maxY; minY++ {
        for x = minX, i = x + minY * size; !found && x < maxX; x++, i++ {
          found = maskData[i] > 0
        }
        if found {
          break
        }
      }

      # Trim the bottom
      for found = false; minY < maxY; maxY-- {
        for x = minX, i = x + (maxY - 1) * size; !found && x < maxX; x++, i++ {
          found = maskData[i] > 0
        }
        if found {
          break
        }
      }

      # Compact the mask into a linear array of memory
      var width = maxX - minX
      var height = maxY - minY
      var mask = Graphics.Mask.new(width, height)
      var output = mask.pixels
      for y = 0, to = 0; y < height; y++ {
        for x = 0, from = minX + (minY + y) * size; x < width; x++, from++, to += 4 {
          output.setByte(to, maskData[from])
          output.setByte(to + 1, maskData[from] >> 8)
          output.setByte(to + 2, maskData[from] >> 16)
        }
      }

      # Measure 100 successive characters in an attempt to get a better
      # measurement since some browsers never return a fractional value
      return Graphics.Glyph.new(codePoint, mask, originX - minX, originY - minY, advanceWidth)
    }
  }
}
