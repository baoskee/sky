namespace Editor {
  enum TabMove {
    IMMEDIATE
    ANIMATED
  }

  class TabInfo {
    const document Model
    var left = 0.0
    var right = 0.0
    var startLeft = 0.0
    var startRight = 0.0
    var endLeft = 0.0
    var endRight = 0.0
    var animationRemaining = 0.0

    def moveTo(targetLeft double, targetRight double, mode TabMove) {
      switch mode {
        case .IMMEDIATE {
          left = startLeft = endLeft = targetLeft
          right = startRight = endRight = targetRight
          animationRemaining = 0
        }

        case .ANIMATED {
          if animationRemaining == 0 || targetLeft != endLeft || targetRight != endRight {
            startLeft = left
            startRight = right
            endLeft = targetLeft
            endRight = targetRight
            animationRemaining = 1
          }
        }
      }
    }

    def updateAnimation(seconds double) bool {
      if animationRemaining == 0 {
        return false
      }

      animationRemaining -= seconds * ANIMATION_SPEED

      if animationRemaining > 0 {
        var t = 1 - animationRemaining
        t *= t * (3 - 2 * t)
        left = startLeft + (endLeft - startLeft) * t
        right = startRight + (endRight - startRight) * t
      }

      else {
        moveTo(endLeft, endRight, .IMMEDIATE)
      }

      return true
    }
  }

  namespace TabInfo {
    const ANIMATION_SPEED = 5
  }

  class TabsView : UI.View :: WindowObserver, DocumentStoreObserver {
    const _documentStore DocumentStore
    const _controller WindowController
    const _tabs List<TabInfo> = []
    var _previousTime double
    var _draggingOffset = 0.0
    var _draggingIndex = -1
    var _hoveredIndex = -1

    def new(controller WindowController) {
      super(controller.window)
      controller.addObserver(self)
      _controller = controller
      _documentStore = controller.documentStore
      _documentStore.addObserver(self)
      _previousTime = window.platform.nowInSeconds
      assert(_documentStore.documents.isEmpty)
    }

    over render {
      var renderer = window.renderer
      var theme = _theme
      var width = bounds.width + BORDER_ADJUSTMENT
      var height = bounds.height
      var font = renderer.fontInstance(.UI_FONT)
      var activeIndex = _documentStore.activeIndex
      var tabHeight = theme.tabHeight
      var tabs = _tabs
      var advanceWidthIterator = UI.AdvanceWidthIterator.INSTANCE
      var unicodeIterator = Unicode.StringIterator.INSTANCE
      advanceWidthIterator.setFont(font, 0)

      # View background
      if theme.tabArea != null {
        renderer.renderDisplayList(theme.tabArea, DISPLAY_LIST_WIDTH, DISPLAY_LIST_HEIGHT, 0, 0, width, height)
      }

      # Inactive tabs
      if theme.inactiveTab != null {
        for i = tabs.count - 1; i >= 0; i-- {
          if i != activeIndex {
            var tab = tabs[i]
            renderer.renderDisplayList(theme.inactiveTab, DISPLAY_LIST_WIDTH, DISPLAY_LIST_HEIGHT, tab.left, height - tabHeight, tab.right - tab.left, tabHeight)
          }
        }
      }

      # Draw tab text all at once for better batching
      for i in 0..tabs.count {
        if i != activeIndex {
          _renderTabText(tabs[i], font, advanceWidthIterator, unicodeIterator, false, _hoveredIndex == i)
        }
      }

      # # Do the active tab last so it comes on top
      if activeIndex != -1 && theme.activeTab != null {
        var tab = tabs[activeIndex]
        renderer.renderDisplayList(theme.activeTab, DISPLAY_LIST_WIDTH, DISPLAY_LIST_HEIGHT, tab.left, height - tabHeight, tab.right - tab.left, tabHeight)
      }

      # Draw the active tab text last in its own batch
      if activeIndex != -1 {
        _renderTabText(tabs[activeIndex], font, advanceWidthIterator, unicodeIterator, true, _hoveredIndex == activeIndex)
      }
    }

    def _renderTabText(tab TabInfo, font UI.FontInstance, advanceWidthIterator UI.AdvanceWidthIterator, unicodeIterator Unicode.StringIterator, isActive bool, isHovered bool) {
      var theme = _theme
      var text = tab.document.name
      advanceWidthIterator.reset(text)
      advanceWidthIterator.seekToIndex(text.count)
      assert(theme.tabTextAlignment != .RIGHT)
      assert(theme.closeButtonAlignment != .CENTER)

      # Truncate text to fit
      var padding = theme.tabOverlap + theme.tabTextPadding
      var maxWidth = tab.right - tab.left - (isHovered || !theme.onlyShowCloseButtonOnHover ? theme.closeButtonWidth : 0) - 2 * padding
      var textWidth = advanceWidthIterator.advanceWidthFromLeft
      if textWidth > maxWidth {
        var ellipsisAdvanceWidth = font.advanceWidth('…')
        maxWidth -= ellipsisAdvanceWidth
        unicodeIterator.reset(text, advanceWidthIterator.currentIndex)

        # Trim the end of the text until it fits
        while advanceWidthIterator.advanceWidthFromLeft > maxWidth && unicodeIterator.previousCodePoint != -1 {
          advanceWidthIterator.seekToIndex(unicodeIterator.index)
        }

        # Append the ellipsis to the end
        textWidth = advanceWidthIterator.advanceWidthFromLeft + ellipsisAdvanceWidth
        text = text.slice(0, advanceWidthIterator.currentIndex) + "…"
      }

      # Render text
      var tabHeight = theme.tabHeight
      var offset = Math.round((tabHeight - font.lineHeight) / 2)
      var x =
        theme.tabTextAlignment == .LEFT ? tab.left + padding :
        (tab.left + tab.right - textWidth) / 2
      var y = bounds.height - tabHeight
      var renderer = window.renderer
      renderer.renderText(x + theme.textShadowOffsetX, y + offset + theme.textShadowOffsetY, text, .UI_FONT, .FOREGROUND_TABS_SHADOW, 255)
      renderer.renderText(x, y + offset, text, .UI_FONT, isActive ? .FOREGROUND_TABS_ACTIVE : .FOREGROUND_TABS_INACTIVE, 255)

      # Render the close button
      if (isHovered || !theme.onlyShowCloseButtonOnHover) && theme.closeButton != null {
        renderer.renderDisplayList(theme.closeButton, DISPLAY_LIST_WIDTH, DISPLAY_LIST_HEIGHT,
          tab.left + padding, y, tab.right - tab.left - 2 * padding, tabHeight)
      }

      # # Render the close button hit target for debugging
      # if theme.closeButtonAlignment == .LEFT {
      #   renderer.renderDisplayList(Graphics.DisplayList.new([
      #     Graphics.DisplayCommand.CLEAR, Graphics.RGBA.hex(0xFF0000, 127) as int,
      #   ]), 9999, 9999, tab.left + theme.tabOverlap, y, theme.closeButtonWidth, tabHeight)
      # } else {
      #   renderer.renderDisplayList(Graphics.DisplayList.new([
      #     Graphics.DisplayCommand.CLEAR, Graphics.RGBA.hex(0xFF0000, 127) as int,
      #   ]), 9999, 9999, tab.right - theme.closeButtonWidth - theme.tabOverlap, y, theme.closeButtonWidth, tabHeight)
      # }
    }

    def _indexOfTabForEvent(event UI.MouseEvent) int {
      var location = event.locationInView(self)
      var tabs = _tabs

      if location.y >= 0 && location.y < bounds.height {
        for i in 0..tabs.count {
          var tab = tabs[i]
          if location.x >= tab.left && location.x < tab.right {
            return i
          }
        }
      }

      return -1
    }

    over handleEvent(event UI.Event) {
      if event.type.isMouseEvent {
        window.setCursor(.ARROW)
      }

      switch event.type {
        case .MOUSE_DOWN {
          var index = _indexOfTabForEvent(event.mouseEvent)

          # Click on an existing tab
          if index != -1 {
            _documentStore.setActiveIndex(index)
            _draggingOffset = event.mouseEvent.locationInView(self).x - _tabs[index].left
            _draggingIndex = _hoveredIndex = index
            event.accept
          }

          # Create a new tab
          else if event.mouseEvent.clickCount % 2 == 0 {
            _documentStore.appendDocument(_controller.createNewDocument)
            event.accept
          }
        }

        case .MOUSE_MOVE {
          if _draggingIndex != -1 {
            var theme = _theme
            var tabCount = _tabs.count
            var location = event.mouseEvent.locationInView(self)
            var trackWidth = bounds.width + BORDER_ADJUSTMENT - theme.tabOverlap
            var tabWidth = Math.min(trackWidth / tabCount, theme.tabMaxWidth - theme.tabOverlap)
            var left = Math.clamp(location.x - _draggingOffset, 0, trackWidth - tabWidth)
            var oldIndex = _draggingIndex
            var tab = _tabs[oldIndex]
            var newIndex = Math.clamp(Math.round(left / tabWidth), 0, tabCount - 1) as int
            _documentStore.moveDocument(oldIndex, newIndex)
            _draggingIndex = newIndex
            _hoveredIndex = newIndex
            tab.moveTo(Math.round(left), Math.round(left + tabWidth + theme.tabOverlap), .IMMEDIATE)
            _window.invalidate
          }

          else {
            var index = _indexOfTabForEvent(event.mouseEvent)
            if index != _hoveredIndex {
              _hoveredIndex = index
              window.invalidate
            }
          }
        }

        case .MOUSE_UP {
          if _draggingIndex != -1 {
            updateTabTargets(.ANIMATED)
            _draggingIndex = -1
            _hoveredIndex = _indexOfTabForEvent(event.mouseEvent)
          }
        }

        case .MOUSE_LEAVE {
          if _hoveredIndex != -1 {
            _hoveredIndex = -1
            window.invalidate
          }
        }
      }
    }

    def handleAction(action Action) {
    }

    def handleFrame {
      var currentTime = _window.platform.nowInSeconds
      var seconds = currentTime - _previousTime
      _previousTime = currentTime

      # Ignore long pauses when the app goes idle
      if seconds < 0 || seconds > 0.25 {
        return
      }

      # Update tab animations
      for tab in _tabs {
        if tab.updateAnimation(seconds) {
          _window.invalidate
        }
      }
    }

    def _createTabForDocument(document Model) TabInfo {
      var tab = TabInfo.new(document)
      if !_tabs.isEmpty {
        tab.left = tab.right = _tabs.last.right - _theme.tabOverlap
      }
      return tab
    }

    def handleDocumentStoreChange(moved Model, from int, to int) {
      _draggingIndex = -1

      # Keep the list of tabs in sync with the list of documents
      if moved != null {
        if from == -1 { _tabs.insert(to, _createTabForDocument(moved)) }
        else if to == -1 { _tabs.removeAt(from) }
        else { _tabs.insert(to, _tabs.takeAt(from)) }
      }

      updateTabTargets(from == -1 && to != -1 && _tabs.count == 1 ? .IMMEDIATE : .ANIMATED)
    }

    over handleSizeChange {
      updateTabTargets(.IMMEDIATE)
    }

    def updateTabTargets(mode TabMove) {
      var tabs = _tabs
      var count = tabs.count
      var theme = _theme
      var scale = Math.min((bounds.width + BORDER_ADJUSTMENT - theme.tabOverlap) / count, theme.tabMaxWidth - theme.tabOverlap)

      for i in 0..count {
        tabs[i].moveTo(
          Math.round(i * scale),
          Math.round((i + 1) * scale + theme.tabOverlap),
          mode)
      }
    }
  }

  namespace TabsView {
    const DISPLAY_LIST_HEIGHT = 100
    const DISPLAY_LIST_WIDTH = 100
    const BORDER_ADJUSTMENT = 1 # Make the width 1px bigger on the right so that tab borders are hidden on both sides
  }
}
