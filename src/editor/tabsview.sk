namespace Editor {
  class TabsView : UI.View :: WindowObserver {
    const _documentStore DocumentStore
    const _controller WindowController
    var _tabLeft = 0.0
    var _tabRight = 0.0

    def new(controller WindowController) {
      super(controller.window)
      controller.addObserver(self)
      _controller = controller
      _documentStore = controller.documentStore
    }

    def _loadTabRange(index int) {
      var scale = Math.min((bounds.width - NEW_TAB_WIDTH) / _documentStore.documents.count, MAX_TAB_WIDTH)
      _tabLeft = Math.round(index * scale)
      _tabRight = Math.round((index + 1) * scale)
    }

    over render {
      var renderer = window.renderer
      var width = bounds.width
      var height = bounds.height
      var font = renderer.fontInstance(.UI_FONT)
      var offset = Math.round((height - font.lineHeight) / 2)
      var documents = _documentStore.documents
      var activeIndex = _documentStore.activeIndex

      # View background
      renderer.renderRect(0, 0, width, height, .BACKGROUND_TABS_INACTIVE)

      # Tab backgrounds and borders
      for i = documents.count - 1; i >= 0; i-- {
        _loadTabRange(i)
        if i == activeIndex {
          renderer.renderRect(_tabLeft, 0, _tabRight - _tabLeft, height, .BACKGROUND_TABS_ACTIVE)
          renderer.renderRect(_tabLeft, height - 2, _tabRight - _tabLeft, 2, .BORDER_TABS_BASE)
        }
        renderer.renderRect(_tabRight, 0, 1, height, .BORDER_TABS)
      }

      # New tab plus
      var newTabX = width - NEW_TAB_WIDTH / 2
      var halfSize = (height as int) >> 1
      var quarterSize = halfSize >> 1
      renderer.renderHorizontalLine(newTabX - quarterSize + 1, newTabX + quarterSize, halfSize, .FOREGROUND_TABS_INACTIVE)
      renderer.renderVerticalLine(newTabX, halfSize - quarterSize + 1, halfSize + quarterSize, .FOREGROUND_TABS_INACTIVE)

      # Outside border
      renderer.renderRect(0, height - 1, width, 1, .BORDER_TABS)

      # Draw tab text last for better batching
      var iterator = UI.AdvanceWidthIterator.INSTANCE
      iterator.setFont(font, 0)
      for i in 0..documents.count {
        var text = documents[i].name # TODO: â€¦
        iterator.reset(text)
        iterator.seekToIndex(text.count)
        _loadTabRange(i)
        var x = (_tabLeft + _tabRight - iterator.advanceWidthFromLeft) / 2
        renderer.renderText(x, offset + 1, text, .UI_FONT, .FOREGROUND_TABS_SHADOW, 255)
        renderer.renderText(x, offset, text, .UI_FONT, i == activeIndex ? .FOREGROUND_TABS_ACTIVE : .FOREGROUND_TABS_INACTIVE, 255)
      }
    }

    over handleEvent(event UI.Event) {
      if event.type.isMouseEvent {
        window.setCursor(.ARROW)
      }

      switch event.type {
        case .MOUSE_DOWN {
          var location = event.mouseEvent.locationInView(self)

          # Click on an existing tab
          for i in 0.._documentStore.documents.count {
            _loadTabRange(i)
            if location.x >= _tabLeft && location.x < _tabRight {
              _documentStore.setActiveIndex(i)
              event.accept
              return
            }
          }

          # Create a new tab
          if location.x >= bounds.width - NEW_TAB_WIDTH || event.mouseEvent.clickCount % 2 == 0 {
            _documentStore.appendDocument(_controller.createNewDocument)
            event.accept
          }
        }
      }
    }

    def _changeActiveIndex(index int) {
      if index >= 0 && index < _documentStore.documents.count {
        _documentStore.setActiveIndex(index)
      }
    }

    def handleAction(action Action) {
      var count = _documentStore.documents.count
      var activeIndex = _documentStore.activeIndex

      switch action {
        case .NEW_DOCUMENT { _documentStore.appendDocument(_controller.createNewDocument) }
        case .CLOSE_DOCUMENT { if activeIndex != -1 { _documentStore.removeDocument(activeIndex) } }

        case .TABS_PREVIOUS { _changeActiveIndex((activeIndex - 1) %% count) }
        case .TABS_NEXT { _changeActiveIndex((activeIndex + 1) % count) }
        case .TABS_1 { _changeActiveIndex(0) }
        case .TABS_2 { _changeActiveIndex(1) }
        case .TABS_3 { _changeActiveIndex(2) }
        case .TABS_4 { _changeActiveIndex(3) }
        case .TABS_5 { _changeActiveIndex(4) }
        case .TABS_6 { _changeActiveIndex(5) }
        case .TABS_7 { _changeActiveIndex(6) }
        case .TABS_8 { _changeActiveIndex(7) }
        case .TABS_LAST { _changeActiveIndex(count - 1) }
      }
    }

    def handleFrame {
    }
  }

  namespace TabsView {
    const MAX_TAB_WIDTH = 250.0
    const NEW_TAB_WIDTH = 26
    const HEIGHT = 27
  }
}
