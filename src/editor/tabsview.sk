namespace Editor {
  enum TabMove {
    IMMEDIATE
    ANIMATED
  }

  class TabInfo {
    const document Model
    var left = 0.0
    var right = 0.0
    var startLeft = 0.0
    var startRight = 0.0
    var endLeft = 0.0
    var endRight = 0.0
    var animationRemaining = 0.0

    def moveTo(targetLeft double, targetRight double, mode TabMove) {
      switch mode {
        case .IMMEDIATE {
          left = startLeft = endLeft = targetLeft
          right = startRight = endRight = targetRight
          animationRemaining = 0
        }

        case .ANIMATED {
          if animationRemaining == 0 || targetLeft != endLeft || targetRight != endRight {
            startLeft = left
            startRight = right
            endLeft = targetLeft
            endRight = targetRight
            animationRemaining = 1
          }
        }
      }
    }

    def updateAnimation(seconds double) bool {
      if animationRemaining == 0 {
        return false
      }

      animationRemaining -= seconds * ANIMATION_SPEED

      if animationRemaining > 0 {
        var t = 1 - animationRemaining
        t *= t * (3 - 2 * t)
        left = startLeft + (endLeft - startLeft) * t
        right = startRight + (endRight - startRight) * t
      }

      else {
        moveTo(endLeft, endRight, .IMMEDIATE)
      }

      return true
    }
  }

  namespace TabInfo {
    const ANIMATION_SPEED = 5
  }

  class TabsView : UI.View :: WindowObserver, DocumentStoreObserver {
    const _documentStore DocumentStore
    const _controller WindowController
    const _tabs List<TabInfo> = []
    var _previousTime double
    var _draggingOffset = 0.0
    var _draggingIndex = -1

    def new(controller WindowController) {
      super(controller.window)
      controller.addObserver(self)
      _controller = controller
      _documentStore = controller.documentStore
      _documentStore.addObserver(self)
      _previousTime = _window.platform.nowInSeconds
      assert(_documentStore.documents.isEmpty)
    }

    over render {
      var renderer = window.renderer
      var width = bounds.width
      var height = bounds.height
      var font = renderer.fontInstance(.UI_FONT)
      var activeIndex = _documentStore.activeIndex
      var tabs = _tabs
      var advanceWidthIterator = UI.AdvanceWidthIterator.INSTANCE
      var unicodeIterator = Unicode.StringIterator.INSTANCE
      advanceWidthIterator.setFont(font, 0)

      # View background
      renderer.renderRect(0, 0, width, height, .BACKGROUND_TABS_INACTIVE)

      # Tab backgrounds and borders
      for i = tabs.count - 1; i >= 0; i-- {
        var tab = tabs[i]
        if i != activeIndex {
          renderer.renderRect(tab.left - 1, 0, 1, height, .BORDER_TABS)
          renderer.renderRect(tab.right - 1, 0, 1, height, .BORDER_TABS)
        }
      }

      # New tab plus
      var newTabX = width - NEW_TAB_WIDTH / 2
      var halfSize = (height as int) >> 1
      var quarterSize = halfSize >> 1
      renderer.renderHorizontalLine(newTabX - quarterSize + 1, newTabX + quarterSize, halfSize, .FOREGROUND_TABS_INACTIVE)
      renderer.renderVerticalLine(newTabX, halfSize - quarterSize + 1, halfSize + quarterSize, .FOREGROUND_TABS_INACTIVE)

      # Draw tab text all at once for better batching
      for i in 0..tabs.count {
        if i != activeIndex {
          _renderTabText(tabs[i], font, advanceWidthIterator, unicodeIterator, false)
        }
      }

      # Do the active tab last so it comes on top
      if activeIndex != -1 {
        var tab = tabs[activeIndex]
        renderer.renderRect(tab.left, 0, tab.right - tab.left, height, .BACKGROUND_TABS_ACTIVE)
        renderer.renderRect(tab.left, height - 2, tab.right - tab.left, 2, .BORDER_TABS_BASE)
        renderer.renderRect(tab.left - 1, 0, 1, height, .BORDER_TABS)
        renderer.renderRect(tab.right - 1, 0, 1, height, .BORDER_TABS)
      }

      # Draw the bottom border in the same batch as the active tab geometry
      renderer.renderRect(0, height - 1, width, 1, .BORDER_TABS)

      # Draw the active tab text last in its own batch
      if activeIndex != -1 {
        _renderTabText(tabs[activeIndex], font, advanceWidthIterator, unicodeIterator, true)
      }
    }

    def _renderTabText(tab TabInfo, font UI.FontInstance, advanceWidthIterator UI.AdvanceWidthIterator, unicodeIterator Unicode.StringIterator, isActive bool) {
      var text = tab.document.name
      advanceWidthIterator.reset(text)
      advanceWidthIterator.seekToIndex(text.count)

      # Truncate text to fit
      var maxWidth = tab.right - tab.left - 10
      var textWidth = advanceWidthIterator.advanceWidthFromLeft
      if textWidth > maxWidth {
        var ellipsisAdvanceWidth = font.advanceWidth('…')
        maxWidth -= ellipsisAdvanceWidth
        unicodeIterator.reset(text, advanceWidthIterator.currentIndex)

        # Trim the end of the text until it fits
        while advanceWidthIterator.advanceWidthFromLeft > maxWidth && unicodeIterator.previousCodePoint != -1 {
          advanceWidthIterator.seekToIndex(unicodeIterator.index)
        }

        # Append the ellipsis to the end
        textWidth = advanceWidthIterator.advanceWidthFromLeft + ellipsisAdvanceWidth
        text = text.slice(0, advanceWidthIterator.currentIndex) + "…"
      }

      var x = (tab.left + tab.right - textWidth) / 2
      var offset = Math.round((bounds.height - font.lineHeight) / 2)
      var renderer = window.renderer
      renderer.renderText(x, offset + 1, text, .UI_FONT, .FOREGROUND_TABS_SHADOW, 255)
      renderer.renderText(x, offset, text, .UI_FONT, isActive ? .FOREGROUND_TABS_ACTIVE : .FOREGROUND_TABS_INACTIVE, 255)
    }

    over handleEvent(event UI.Event) {
      if event.type.isMouseEvent {
        window.setCursor(.ARROW)
      }

      switch event.type {
        case .MOUSE_DOWN {
          var location = event.mouseEvent.locationInView(self)
          var tabs = _tabs

          # Click on an existing tab
          for i in 0..tabs.count {
            var tab = tabs[i]
            if location.x >= tab.left && location.x < tab.right {
              _documentStore.setActiveIndex(i)
              _draggingOffset = location.x - tab.left
              _draggingIndex = i
              event.accept
              return
            }
          }

          # Create a new tab
          if location.x >= bounds.width - NEW_TAB_WIDTH || event.mouseEvent.clickCount % 2 == 0 {
            _documentStore.appendDocument(_controller.createNewDocument)
            event.accept
          }
        }

        case .MOUSE_MOVE {
          if _draggingIndex != -1 {
            var tabCount = _tabs.count
            var location = event.mouseEvent.locationInView(self)
            var trackWidth = bounds.width - NEW_TAB_WIDTH
            var tabWidth = Math.min(trackWidth / tabCount, MAX_TAB_WIDTH)
            var left = Math.clamp(location.x - _draggingOffset, 0, trackWidth - tabWidth)
            var oldIndex = _draggingIndex
            var tab = _tabs[oldIndex]
            var newIndex = Math.clamp(Math.round(left / tabWidth), 0, tabCount - 1) as int
            _documentStore.moveDocument(oldIndex, newIndex)
            _draggingIndex = newIndex
            tab.moveTo(Math.round(left), Math.round(left + tabWidth), .IMMEDIATE)
            _window.invalidate
          }
        }

        case .MOUSE_UP {
          if _draggingIndex != -1 {
            updateTabTargets(.ANIMATED)
            _draggingIndex = -1
          }
        }
      }
    }

    def _changeActiveIndex(index int) {
      if index >= 0 && index < _documentStore.documents.count {
        _documentStore.setActiveIndex(index)
      }
    }

    def handleAction(action Action) {
      var count = _documentStore.documents.count
      var activeIndex = _documentStore.activeIndex

      switch action {
        case .NEW_DOCUMENT { _documentStore.appendDocument(_controller.createNewDocument) }
        case .CLOSE_DOCUMENT { if activeIndex != -1 { _documentStore.removeDocument(activeIndex) } }

        case .TABS_PREVIOUS { _changeActiveIndex((activeIndex - 1) %% count) }
        case .TABS_NEXT { _changeActiveIndex((activeIndex + 1) % count) }
        case .TABS_1 { _changeActiveIndex(0) }
        case .TABS_2 { _changeActiveIndex(1) }
        case .TABS_3 { _changeActiveIndex(2) }
        case .TABS_4 { _changeActiveIndex(3) }
        case .TABS_5 { _changeActiveIndex(4) }
        case .TABS_6 { _changeActiveIndex(5) }
        case .TABS_7 { _changeActiveIndex(6) }
        case .TABS_8 { _changeActiveIndex(7) }
        case .TABS_LAST { _changeActiveIndex(count - 1) }
      }
    }

    def handleFrame {
      var currentTime = _window.platform.nowInSeconds
      var seconds = currentTime - _previousTime
      _previousTime = currentTime

      # Ignore long pauses when the app goes idle
      if seconds < 0 || seconds > 0.25 {
        return
      }

      # Update tab animations
      for tab in _tabs {
        if tab.updateAnimation(seconds) {
          _window.invalidate
        }
      }
    }

    def _createTabForDocument(document Model) TabInfo {
      var tab = TabInfo.new(document)
      if !_tabs.isEmpty {
        tab.left = tab.right = _tabs.last.right
      }
      return tab
    }

    def handleDocumentStoreChange(moved Model, from int, to int) {
      _draggingIndex = -1

      # Keep the list of tabs in sync with the list of documents
      if moved != null {
        if from == -1 { _tabs.insert(to, _createTabForDocument(moved)) }
        else if to == -1 { _tabs.removeAt(from) }
        else { _tabs.insert(to, _tabs.takeAt(from)) }
      }

      updateTabTargets(from == -1 && to != -1 && _tabs.count == 1 ? .IMMEDIATE : .ANIMATED)
    }

    over handleSizeChange {
      updateTabTargets(.IMMEDIATE)
    }

    def updateTabTargets(mode TabMove) {
      var tabs = _tabs
      var count = tabs.count
      var scale = Math.min((bounds.width - NEW_TAB_WIDTH) / count, MAX_TAB_WIDTH)

      for i in 0..count {
        tabs[i].moveTo(Math.round(i * scale), Math.round((i + 1) * scale), mode)
      }
    }
  }

  namespace TabsView {
    const MAX_TAB_WIDTH = 250.0
    const NEW_TAB_WIDTH = 26
    const HEIGHT = 27
  }
}
