namespace Editor {
  enum TabMove {
    IMMEDIATE
    ANIMATED
  }

  class TabInfo {
    const document Model
    var left = 0.0
    var right = 0.0
    var startLeft = 0.0
    var startRight = 0.0
    var endLeft = 0.0
    var endRight = 0.0
    var animationRemaining = 0.0

    def moveTo(targetLeft double, targetRight double, mode TabMove) {
      switch mode {
        case .IMMEDIATE {
          left = startLeft = endLeft = targetLeft
          right = startRight = endRight = targetRight
          animationRemaining = 0
        }

        case .ANIMATED {
          startLeft = left
          startRight = right
          endLeft = targetLeft
          endRight = targetRight
          animationRemaining = 1
        }
      }
    }

    def updateAnimation(seconds double) bool {
      if animationRemaining == 0 {
        return false
      }

      animationRemaining -= seconds * ANIMATION_SPEED

      if animationRemaining > 0 {
        var t = 1 - animationRemaining
        t *= t * (3 - 2 * t)
        left = startLeft + (endLeft - startLeft) * t
        right = startRight + (endRight - startRight) * t
      }

      else {
        moveTo(endLeft, endRight, .IMMEDIATE)
      }

      return true
    }
  }

  namespace TabInfo {
    const ANIMATION_SPEED = 4
  }

  class TabsView : UI.View :: WindowObserver, DocumentStoreObserver {
    const _documentStore DocumentStore
    const _controller WindowController
    const _tabs List<TabInfo> = []
    var _previousTime double

    def new(controller WindowController) {
      super(controller.window)
      controller.addObserver(self)
      _controller = controller
      _documentStore = controller.documentStore
      _documentStore.addObserver(self)
      _previousTime = _window.platform.nowInSeconds
      assert(_documentStore.documents.isEmpty)
    }

    over render {
      var renderer = window.renderer
      var width = bounds.width
      var height = bounds.height
      var font = renderer.fontInstance(.UI_FONT)
      var offset = Math.round((height - font.lineHeight) / 2)
      var activeIndex = _documentStore.activeIndex
      var tabs = _tabs

      # View background
      renderer.renderRect(0, 0, width, height, .BACKGROUND_TABS_INACTIVE)

      # Tab backgrounds and borders
      for i = tabs.count - 1; i >= 0; i-- {
        var tab = tabs[i]
        if i == activeIndex {
          renderer.renderRect(tab.left, 0, tab.right - tab.left, height, .BACKGROUND_TABS_ACTIVE)
          renderer.renderRect(tab.left, height - 2, tab.right - tab.left, 2, .BORDER_TABS_BASE)
        }
        renderer.renderRect(tab.right, 0, 1, height, .BORDER_TABS)
      }

      # New tab plus
      var newTabX = width - NEW_TAB_WIDTH / 2
      var halfSize = (height as int) >> 1
      var quarterSize = halfSize >> 1
      renderer.renderHorizontalLine(newTabX - quarterSize + 1, newTabX + quarterSize, halfSize, .FOREGROUND_TABS_INACTIVE)
      renderer.renderVerticalLine(newTabX, halfSize - quarterSize + 1, halfSize + quarterSize, .FOREGROUND_TABS_INACTIVE)

      # Outside border
      renderer.renderRect(0, height - 1, width, 1, .BORDER_TABS)

      # Draw tab text last for better batching
      var iterator = UI.AdvanceWidthIterator.INSTANCE
      iterator.setFont(font, 0)
      for i in 0..tabs.count {
        var tab = tabs[i]
        var text = tab.document.name # TODO: â€¦
        iterator.reset(text)
        iterator.seekToIndex(text.count)
        var x = (tab.left + tab.right - iterator.advanceWidthFromLeft) / 2
        renderer.renderText(x, offset + 1, text, .UI_FONT, .FOREGROUND_TABS_SHADOW, 255)
        renderer.renderText(x, offset, text, .UI_FONT, i == activeIndex ? .FOREGROUND_TABS_ACTIVE : .FOREGROUND_TABS_INACTIVE, 255)
      }
    }

    over handleEvent(event UI.Event) {
      if event.type.isMouseEvent {
        window.setCursor(.ARROW)
      }

      switch event.type {
        case .MOUSE_DOWN {
          var location = event.mouseEvent.locationInView(self)
          var tabs = _tabs

          # Click on an existing tab
          for i in 0..tabs.count {
            var tab = tabs[i]
            if location.x >= tab.left && location.x < tab.right {
              _documentStore.setActiveIndex(i)
              event.accept
              return
            }
          }

          # Create a new tab
          if location.x >= bounds.width - NEW_TAB_WIDTH || event.mouseEvent.clickCount % 2 == 0 {
            _documentStore.appendDocument(_controller.createNewDocument)
            event.accept
          }
        }
      }
    }

    def _changeActiveIndex(index int) {
      if index >= 0 && index < _documentStore.documents.count {
        _documentStore.setActiveIndex(index)
      }
    }

    def handleAction(action Action) {
      var count = _documentStore.documents.count
      var activeIndex = _documentStore.activeIndex

      switch action {
        case .NEW_DOCUMENT { _documentStore.appendDocument(_controller.createNewDocument) }
        case .CLOSE_DOCUMENT { if activeIndex != -1 { _documentStore.removeDocument(activeIndex) } }

        case .TABS_PREVIOUS { _changeActiveIndex((activeIndex - 1) %% count) }
        case .TABS_NEXT { _changeActiveIndex((activeIndex + 1) % count) }
        case .TABS_1 { _changeActiveIndex(0) }
        case .TABS_2 { _changeActiveIndex(1) }
        case .TABS_3 { _changeActiveIndex(2) }
        case .TABS_4 { _changeActiveIndex(3) }
        case .TABS_5 { _changeActiveIndex(4) }
        case .TABS_6 { _changeActiveIndex(5) }
        case .TABS_7 { _changeActiveIndex(6) }
        case .TABS_8 { _changeActiveIndex(7) }
        case .TABS_LAST { _changeActiveIndex(count - 1) }
      }
    }

    def handleFrame {
      var currentTime = _window.platform.nowInSeconds
      var seconds = currentTime - _previousTime
      _previousTime = currentTime

      # Ignore long pauses when the app goes idle
      if seconds < 0 || seconds > 0.25 {
        return
      }

      # Update tab animations
      for tab in _tabs {
        if tab.updateAnimation(seconds) {
          _window.invalidate
        }
      }
    }

    def _createTabForDocument(document Model) TabInfo {
      var tab = TabInfo.new(document)
      if !_tabs.isEmpty {
        tab.left = tab.right = _tabs.last.right
      }
      return tab
    }

    def handleDocumentStoreChange(moved Model, from int, to int) {
      # Keep the list of tabs in sync with the list of documents
      if moved != null {
        if from == -1 { _tabs.insert(to, _createTabForDocument(moved)) }
        else if to == -1 { _tabs.removeAt(from) }
        else { _tabs.insert(to, _tabs.takeAt(from)) }
      }

      updateTabTargets(.ANIMATED)
    }

    over handleSizeChange {
      updateTabTargets(.IMMEDIATE)
    }

    def updateTabTargets(mode TabMove) {
      var tabs = _tabs
      var count = tabs.count
      var scale = Math.min((bounds.width - NEW_TAB_WIDTH) / count, MAX_TAB_WIDTH)

      for i in 0..count {
        tabs[i].moveTo(Math.round(i * scale), Math.round((i + 1) * scale), mode)
      }
    }
  }

  namespace TabsView {
    const MAX_TAB_WIDTH = 250.0
    const NEW_TAB_WIDTH = 26
    const HEIGHT = 27
  }
}
