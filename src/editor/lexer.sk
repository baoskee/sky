namespace Editor {
  class Span {
    const start int
    const end int
    const offsetX double
    const advanceWidth double
    const color UI.Color
  }

  class LexerState {
    def equals(other LexerState) bool {
      return other == self
    }
  }

  # A resumable lexer that styles lines of text. Custom lexers can easily be
  # created by creating a new Lexer. There is an optional state system if
  # you need to track information across lines. For example, a multi-line
  # comment would use a different lexer state for the next line than a single-
  # line comment. For simple enum-style state, just creating a fixed number of
  # LexerState objects and check for equality. More advanced usage can be done
  # by subclassing LexerState, adding extra fields, and overriding equals().
  class Lexer {
    const _tokenizeLine fn(Lexer)
    var _spans List<Span> = null
    var _state LexerState = null
    var _current Line = null
    var _currentIndex = 0
    var _nextCodePoint = 0
    var _limit = 0
    var _startOfState = 0
    var _iterator = UI.AdvanceWidthIterator.new

    def styleLine(line Line, previousState LexerState) {
      _state = previousState
      _iterator.reset(line.text)
      _current = line
      _currentIndex = 0
      _nextCodePoint = -1
      _startOfState = 0
      _limit = line.text.count
      _spans = []
      _tokenizeLine(self)
      line.previousState = previousState
      line.nextState = _state
      line.spans = _spans
      assert(_state != null)
    }

    def setFont(font UI.FontInstance, indent int) {
      _iterator.setFont(font, indent)
    }

    def currentText string {
      return _current.text
    }

    def currentIndex int {
      return _currentIndex
    }

    def currentState LexerState {
      return _state
    }

    def endOfLine int {
      return _limit
    }

    def hasNext bool {
      return _currentIndex < _limit
    }

    def next {
      assert(_iterator.currentIndex >= _currentIndex)
      if _currentIndex == _iterator.currentIndex {
        _iterator.nextCodePoint
      }
      _currentIndex = _iterator.currentIndex
    }

    def startOfState int {
      return _startOfState
    }

    def peekNext int {
      _loadNextIfNeeded
      return _nextCodePoint
    }

    def takeNext int {
      var c = peekNext
      next
      return c
    }

    def matchNext(c int) bool {
      if peekNext == c {
        next
        return true
      }
      return false
    }

    def scanAlphaNumericString string {
      var text = ""
      while hasNext {
        var c = peekNext
        if !Lexer.isAlphaOrDigit(c) {
          break
        }
        next
        text += string.fromCodeUnit(c)
      }
      return text
    }

    def transitionToState(state LexerState, startingIndex int) {
      _state = state
      _startOfState = startingIndex
    }

    def addSpan(start int, end int, color UI.Color) {
      assert(start < end)
      _iterator.seekTo(start)
      var minX = _iterator.advanceWidthFromLeft
      _iterator.seekTo(end)
      var maxX = _iterator.advanceWidthFromLeft
      _spans.append(Span.new(start, end, minX, maxX - minX, color))
      _iterator.seekTo(_currentIndex)
    }

    def changePreviousSpanColor(color UI.Color) {
      var previous = _spans.last
      _spans.last = Span.new(previous.start, previous.end, previous.offsetX, previous.advanceWidth, color)
    }

    def _loadNextIfNeeded {
      assert(_iterator.currentIndex >= _currentIndex)
      if _iterator.currentIndex == _currentIndex {
        _nextCodePoint = _iterator.nextCodePoint
      }
    }
  }

  namespace Lexer {
    def isSpace(c int) bool {
      return c == ' ' || c == '\t'
    }

    def isDigit(c int) bool {
      return c >= '0' && c <= '9'
    }

    def isUpperCase(c int) bool {
      return c >= 'A' && c <= 'Z'
    }

    def isLowerCase(c int) bool {
      return c >= 'a' && c <= 'z'
    }

    def isAlpha(c int) bool {
      return isUpperCase(c) || isLowerCase(c) || c == '_'
    }

    def isAlphaOrDigit(c int) bool {
      return isAlpha(c) || isDigit(c)
    }

    def hasLowerCase(text string) bool {
      for i in 0..text.count {
        if isLowerCase(text[i]) {
          return true
        }
      }
      return false
    }
  }
}
